import { _ISelection, IValue, _IIndex, _Transaction, _SelectExplanation, _Explainer, IndexExpression, IndexOp, IndexKey, _IndexExplanation, Stats, _IAlias, Row } from '../interfaces-private';
import { nil } from '../interfaces';
import { DataSourceBase } from './transform-base';
import { ExprRef, JoinClause } from 'pgsql-ast-parser';
import { SELECT_ALL } from '../execution/clean-results';
interface JoinRaw {
    '>restrictive': Row;
    '>joined': Row;
}
interface JoinStrategy {
    iterate: _ISelection;
    iterateSide: 'joined' | 'restrictive';
    joinIndex: _IIndex;
    onValue: IValue;
    othersPredicate?: IValue;
}
export declare class JoinSelection extends DataSourceBase {
    readonly restrictive: _ISelection;
    readonly joined: _ISelection;
    readonly innerJoin: boolean;
    get isExecutionWithNoResult(): boolean;
    private _columns;
    private seqScanExpression;
    private joinId;
    private columnsMappingParentToThis;
    private indexOnRestrictingTableByValue;
    private indexCache;
    strategies: JoinStrategy[];
    private building;
    private ignoreDupes?;
    private mergeSelect?;
    isOriginOf(a: IValue): boolean;
    get columns(): IValue[];
    entropy(t: _Transaction): number;
    constructor(restrictive: _ISelection, joined: _ISelection, on: JoinClause, innerJoin: boolean);
    private wrap;
    listSelectableIdentities(): Iterable<IValue>;
    private fetchOnStrategies;
    private fetchUsingStrategies;
    private fetchAndStrategies;
    private fetchEqStrategyOn;
    getColumn(column: string | ExprRef): IValue;
    getColumn(column: string | ExprRef, nullIfNotFound?: boolean): IValue | nil;
    stats(t: _Transaction): Stats | null;
    enumerate(t: _Transaction): Iterable<any>;
    selectAlias(alias: string): _IAlias | nil;
    iterateCatastrophicItem(item: any, others: any[], side: 'joined' | 'restrictive', t: _Transaction): Generator<any, void, unknown>;
    private builder;
    iterateStrategyItem(item: any, strategy: JoinStrategy, t: _Transaction): Generator<any, void, unknown>;
    buildItem(l: Row, r: Row): {
        '>joined': any;
        '>restrictive': any;
        [SELECT_ALL]: () => any;
    };
    private merge;
    hasItem(value: JoinRaw): boolean;
    getIndex(forValue: IValue): _IIndex | nil;
    explain(e: _Explainer): _SelectExplanation;
}
export declare class JoinIndex implements _IIndex {
    readonly owner: JoinSelection;
    private base;
    constructor(owner: JoinSelection, base: _IIndex);
    get expressions(): IndexExpression[];
    stats(t: _Transaction, key?: IndexKey): Stats | null;
    iterateKeys(): null;
    entropy(op: IndexOp): number;
    eqFirst(rawKey: IndexKey, t: _Transaction): Row | null;
    private chooseStrategy;
    enumerate(op: IndexOp): Iterable<Row>;
    explain(e: _Explainer): _IndexExplanation;
}
export {};
//# sourceMappingURL=join.d.ts.map